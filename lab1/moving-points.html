<!DOCTYPE html>

<!--
   This page shows an animation of colored disks moving around
   in a canvas, bouncing off the edges.  The program uses WebGL.
   All of the points are drawn as single primitive of type POINTS.
   The color is an attribute in the vertex shader, allowing
   each point to be a different primitive.  The user can decide
   whether to have randomly colored points or to make all the
   points red.  The point size is a uniform variable, so all
   the points are the same size.  However, the user can select
   whether the size is large or small.
-->

<html>
<head>
<meta charset="UTF-8">
<title>Moving Disks in WebGL</title>
<style>
    label {
        margin-left: 30px;
    }
</style>

<script>
"use strict";

const  vertexShaderSource =`#version 300 es
    layout(location = 0) in vec2 a_coords;
    layout(location = 1) in vec3 a_color;
    layout(location = 2) in float a_size;


    out vec3 v_color;
    flat out float v_pointsize;

    uniform float u_width;
    uniform float u_height;
    
    void main() {
        float x = -1.0 + 2.0*(a_coords.x / u_width);
        float y = 1.0 - 2.0*(a_coords.y / u_height);
        gl_Position = vec4(x, y, 0.0, 1.0);
        v_color = a_color;
        v_pointsize = a_size;
        gl_PointSize = a_size;
    }`;

const  fragmentShaderSource =`#version 300 es
    precision highp float;

    in vec3 v_color;
    flat in float v_pointsize;
    
    out vec4 o_color;
    
    uniform float u_dotSize;
    
    void main() {
        if (v_pointsize < u_dotSize) {
            discard;
        }
        float distanceFromCenter = distance( gl_PointCoord, vec2(0.5,0.5) );
        if ( distanceFromCenter >= 0.5) {
            discard;  // don't draw this pixel!
        }

        vec4 color = vec4(v_color, 1.0); 
        if (distanceFromCenter <= u_dotSize/v_pointsize) {
            color = vec4(0, 0, 0, 1);
        } 

        o_color = color;
    }`;

let  canvas;  // The canvas where WebGL draws.
let  gl;  // The WebGL graphics context.

let prog;


let  bufferCoords;     // A vertex buffer object to hold the values for coords.
let  bufferColor;     // A vertex buffer object to hold the values for color.
let  bufferSizes;

let  animating = false;  // is the animation running?

/* Data for the points, including their coordinates, velocities and colors.
   The values for the arrays are created during initialization.  The random
   colors are used when the user selects colored rather than red points.
   The positions of the points are updated for each frame of the animation. */

let POINT_COUNT;

let pointSizes;
let pointCoords;
let pointVelocities;
let pointRandomColors;

function circleCircleCollision(x1, y1, sz1, x2, y2, sz2) {
    let rsz1 = sz1/2
    let rsz2 = sz2/2

    let dx = x1 - x2
    let dy = y1 - y2  

    let rsum = rsz1 + rsz2
    let dis2 = dx*dx + dy*dy
    
    return Math.sqrt(dis2) - rsum;
}

function createPointArrays(pointCount) {
    POINT_COUNT = pointCount;
    pointSizes = new Float32Array(POINT_COUNT)
    pointCoords = new Float32Array( 2*POINT_COUNT );
    pointVelocities = new Float32Array( 2*POINT_COUNT );
    pointRandomColors = new Float32Array( 3*POINT_COUNT );
}


const minSize = 16
const maxSize = 64
function setPointData(pointCount) { // called during initialization to fill the arrays with data.
    createPointArrays(pointCount)
    for (let i = 0; i < POINT_COUNT; i++) {
        pointSizes[i] = minSize + Math.random()*(maxSize - minSize)
        
        o: for (;;) {
            // [sz/2, canvas.width - sz/2]
            // [sz/2, canvas.height - sz/2]
            pointCoords[2*i] = pointSizes[i]/2 + ((canvas.width - pointSizes[i]/2) - pointSizes[i]/2) * Math.random();  // x-coordinate of point
            pointCoords[2*i+1] = pointSizes[i]/2 + ((canvas.height - pointSizes[i]/2) - pointSizes[i]/2) * Math.random();;  // y-coordinate of point

            for (let j = 0; j < i; ++j) {

                let x1 = pointCoords[2*i]
                let y1 = pointCoords[2*i+1]
                let sz1 = pointSizes[i]

                let x2 = pointCoords[2*j]
                let y2 = pointCoords[2*j+1]
                let sz2 = pointSizes[j]


                if (circleCircleCollision(x1, y1, sz1, x2, y2, sz2) < 0) {
                    continue o;
                }
            }
            break;
        }


        let  randomVelocity = 1 + 3*Math.random();
        let  randomAngle = 2*Math.PI * Math.random();
        pointVelocities[2*i] = randomVelocity * Math.cos(randomAngle);
        pointVelocities[2*i+1] = randomVelocity * Math.sin(randomAngle);
    }
    for (let i = 0; i < 3 * POINT_COUNT; i++) {
        // The array contains color components, with three numbers per vertex.
        // The color components are just random numbers in the range zero to 1.
        pointRandomColors[i] = Math.random();
    }
}

function setPointData5a1() { 
    createPointArrays(2)

    pointSizes[0] = 32
    pointSizes[1] = 32

    pointCoords[0] = 100;  // x-coordinate of point
    pointCoords[1] = canvas.height/2;  // y-coordinate of point

    pointCoords[2] = 400;  // x-coordinate of point
    pointCoords[3] = canvas.height/2;  // y-coordinate of point

    pointVelocities[0] = 1;
    pointVelocities[1] = 0;

    pointVelocities[2] = -1;
    pointVelocities[3] = 0;

    for (let i = 0; i < 3 * POINT_COUNT; i++) {
        pointRandomColors[i] = Math.random();
    }
}

function setPointData5a2() { 
    createPointArrays(2)

    pointSizes[0] = 32
    pointSizes[1] = 32

    pointCoords[0] = 100;  // x-coordinate of point
    pointCoords[1] = canvas.height/2;  // y-coordinate of point

    pointCoords[2] = 400;  // x-coordinate of point
    pointCoords[3] = canvas.height/2;  // y-coordinate of point

    pointVelocities[0] = 0;
    pointVelocities[1] = 0;

    pointVelocities[2] = -1;
    pointVelocities[3] = 0;

    for (let i = 0; i < 3 * POINT_COUNT; i++) {
        pointRandomColors[i] = Math.random();
    }
}

function setPointData5a3() { 
    createPointArrays(2)

    pointSizes[0] = 32
    pointSizes[1] = 32

    pointCoords[0] = 100;  // x-coordinate of point
    pointCoords[1] = canvas.height/2;  // y-coordinate of point

    pointCoords[2] = 400;  // x-coordinate of point
    pointCoords[3] = canvas.height/2 + 18;  // y-coordinate of point

    pointVelocities[0] = 1;
    pointVelocities[1] = 0;

    pointVelocities[2] = -1;
    pointVelocities[3] = 0;

    for (let i = 0; i < 3 * POINT_COUNT; i++) {
        pointRandomColors[i] = Math.random();
    }
}



class Vector2 {
    constructor(x, y) {
        this.x = x
        this.y = y
    }
}

function dot(v1, v2) {
    return v1.x*v2.x + v1.y*v2.y
}

function sub(v1, v2) {
    return new Vector2(v1.x - v2.x, v1.y - v2.y)
}

function add(v1, v2) {
    return new Vector2(v1.x + v2.x, v1.y + v2.y)
}

function mul(v, s) {
    return new Vector2(v.x*s, v.y*s)
}

function div(v, s) {
    return new Vector2(v.x/s, v.y/s)
}
// https://www.desmos.com/calculator/3q1paue8hv
function updatePointCoordsForFrame() { // called during an animation, before each frame.
    

    for (let i = 0; i < POINT_COUNT; i += 1) {
        let size = pointSizes[i]/2;
        let xid = 2*i;
        let yid = xid + 1;

        pointCoords[xid] += pointVelocities[xid];
        pointCoords[yid] += pointVelocities[yid];

        if (pointCoords[xid]-size < 0) {
            pointCoords[xid] = size-(pointCoords[xid]-size);// move coord back onto canvas
            pointVelocities[xid] = Math.abs(pointVelocities[xid]); // and make sure point is moving in positive direction
        }
        else if (pointCoords[xid]+size > canvas.width) {
            pointCoords[xid] = canvas.width - (pointCoords[xid]+size - canvas.width) - size;// move coord back onto canvas
            pointVelocities[xid] = -Math.abs(pointVelocities[xid]); // and make sure point is moving in negative direction
        }
        if (pointCoords[yid]-size < 0) {
            pointCoords[yid] = size-(pointCoords[yid]-size);// move coord back onto canvas
            pointVelocities[yid] = Math.abs(pointVelocities[yid]); // and make sure point is moving in positive direction
        }
        else if (pointCoords[yid]+size > canvas.height) {
            pointCoords[yid] = canvas.height - (pointCoords[yid]+size - canvas.height) - size;// move coord back onto canvas
            pointVelocities[yid] = -Math.abs(pointVelocities[yid]); // and make sure point is moving in negative direction
        }
    }


    // collision checking and handling
    for (let i = 0; i < POINT_COUNT; ++i) {
        let coordID1 = 2*i;
        let v1 = new Vector2(pointVelocities[coordID1], pointVelocities[coordID1+1])
        let p1 = new Vector2(pointCoords[coordID1], pointCoords[coordID1+1])
        let sz1 = pointSizes[i];

        for (let j = i+1; j < POINT_COUNT; ++j) {
            let coordID2 = 2*j;
            let v2 = new Vector2(pointVelocities[coordID2], pointVelocities[coordID2+1])
            let p2 = new Vector2(pointCoords[coordID2], pointCoords[coordID2+1])
            let sz2 = pointSizes[j];


            if (circleCircleCollision(p1.x, p1.y, sz1, p2.x, p2.y, sz2) < 0) {
                let dv = sub(v1,v2)
                let dp = sub(p1,p2)

                let rsum = sz1/2 + sz2/2;
                let halfp = dot(dp,dv)/dot(dv,dv)
                let q = (dot(dp,dp) - rsum*rsum) / dot(dv,dv);


                let radicand = halfp*halfp - q
                if (radicand >= 0) {
                    let t1 = -halfp + Math.sqrt(radicand)
                    let t2 = -halfp - Math.sqrt(radicand)
    
                    let t = Math.min(t1, t2)
                    console.log("t: "+t)

                    pointCoords[coordID1] += t*pointVelocities[coordID1]
                    pointCoords[coordID1+1] += t*pointVelocities[coordID1+1]

                    pointCoords[coordID2] += t*pointVelocities[coordID2]
                    pointCoords[coordID2+1] += t*pointVelocities[coordID2+1]

                    p1 = new Vector2(pointCoords[coordID1], pointCoords[coordID1+1])
                    p2 = new Vector2(pointCoords[coordID2], pointCoords[coordID2+1])


                    let normal = sub(p2, p1)
                    let unitnormal = div(normal, Math.sqrt(dot(normal,normal)))

                    let unittangent = new Vector2(-unitnormal.y, unitnormal.x)


                    let v1n = dot(unitnormal, v1)
                    let v1t = dot(unittangent, v1)

                    let v2n = dot(unitnormal, v2)
                    let v2t = dot(unittangent, v2)


                    let r1 = sz1/2;
                    let r2 = sz2/2;

                    let m1 = Math.PI*r1*r1;
                    let m2 = Math.PI*r2*r2;

                    let new_v1n = (v1n*(m1 - m2) + 2*m2*v2n)/(m1 + m2);
                    let new_v2n = (v2n*(m2 - m1) + 2*m1*v1n)/(m1 + m2);

                    let new_v1;
                    {
                        let c1 = mul(unitnormal, new_v1n)
                        let c2 = mul(unittangent, v1t)
                        let c3 = add(c1, c2)
                        new_v1 = c3
                    }
                    let new_v2;
                    {
                        let c1 = mul(unitnormal, new_v2n)
                        let c2 = mul(unittangent, v2t)
                        let c3 = add(c1, c2)
                        new_v2 = c3
                    }

                    pointVelocities[coordID1] = new_v1.x
                    pointVelocities[coordID1+1] = new_v1.y

                    pointVelocities[coordID2] = new_v2.x
                    pointVelocities[coordID2+1] = new_v2.y
                } 
            }
        }
    }
}

class Vector4 {
    constructor(x, y, z, w) {
        this.x = x
        this.y = y
        this.z = z
        this.w = w
    }
}


const black = new Vector4(0, 0, 0, 1)
const gray = new Vector4(0.4, 0.4, 0.4, 1)
const gold = new Vector4(1, 215/255, 0, 1)
const red = new Vector4(1, 0, 0, 1)

/**
 *  Draws the content of the canvas, in this case, one primitive ot
 *  type gl.POINTS, which represents all of the disks in the image.
 */
function draw() {

    let background_color = gray
    let monochrome_color = red


    gl.clearColor(background_color.x, background_color.y, background_color.z, 1);  // specify the color to be used for clearing
    gl.clear(gl.COLOR_BUFFER_BIT);  // clear the canvas (to black)
    
    /* Get options from the user interface. */
    
    let  randomColors = document.getElementById("colorCheckbox").checked;
    let  pointsize = Number(document.getElementById("sizeChoice").value);
    
    /* Set up values for the "coords" attribute, giving point's positions */
    
    gl.bindBuffer(gl.ARRAY_BUFFER, bufferCoords);
    gl.bufferData(gl.ARRAY_BUFFER, pointCoords, gl.STREAM_DRAW);
    
    /* Set up values for the "color" attribute */
    
    if ( randomColors ) { // use the attribute values from the color VBO, filled during initialization
        gl.enableVertexAttribArray(1); 
    }
    else { // turn off vertexAttribArray and set a constant attribute color
        gl.disableVertexAttribArray(1);
        gl.vertexAttrib3f(1, monochrome_color.x, monochrome_color.y, monochrome_color.z, 0);
    }
    
    gl.useProgram(prog)
    gl.uniform1f(gl.getUniformLocation(prog, "u_height"), canvas.height);
    gl.uniform1f(gl.getUniformLocation(prog, "u_width"), canvas.width);
    gl.uniform1f(gl.getUniformLocation(prog, "u_dotSize"), 7.0)
    
    /* Draw all the points with one command. */
   
    gl.drawArrays(gl.POINTS, 0, POINT_COUNT);
    
}

/**
 * Creates a program for use in the WebGL context gl, and returns the
 * identifier for that program.  If an error occurs while compiling or
 * linking the program, an exception of type String is thrown.  The error
 * string contains the compilation or linking error.  If no error occurs,
 * the program identifier is the return value of the function.
 */
function createProgram(vertexShaderSource, fragmentShaderSource) {
   let  vsh = gl.createShader( gl.VERTEX_SHADER );
   gl.shaderSource( vsh, vertexShaderSource );
   gl.compileShader( vsh );
   if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
      throw new Error("Error in vertex shader:  " + gl.getShaderInfoLog(vsh));
   }
   let  fsh = gl.createShader( gl.FRAGMENT_SHADER );
   gl.shaderSource( fsh, fragmentShaderSource );
   gl.compileShader( fsh );
   if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
      throw new Error("Error in fragment shader:  " + gl.getShaderInfoLog(fsh));
   }
   let  prog = gl.createProgram();
   gl.attachShader( prog, vsh );
   gl.attachShader( prog, fsh );
   gl.linkProgram( prog );
   if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
      throw new Error("Link error in program:  " + gl.getProgramInfoLog(prog));
   }
   return prog;
}

/**
 * Initialize the WebGL graphics context
 */
function initGL() {
    console.log(gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
    console.log(gl.getParameter(gl.VERSION));
    console.log(gl.getParameter(gl.RENDERER));

    prog = createProgram(vertexShaderSource, fragmentShaderSource );
    bufferCoords = gl.createBuffer();
    bufferColor = gl.createBuffer();
    bufferSizes = gl.createBuffer()

    setPointData(20);

    // setPointData5a1();
    // setPointData5a2();
    // setPointData5a3();

    gl.bindBuffer(gl.ARRAY_BUFFER, bufferCoords);
    gl.bufferData(gl.ARRAY_BUFFER, pointCoords, gl.STREAM_DRAW);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0); 

    gl.bindBuffer(gl.ARRAY_BUFFER, bufferColor);
    gl.bufferData(gl.ARRAY_BUFFER, pointRandomColors, gl.STREAM_DRAW);
    gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(1); 

    gl.bindBuffer(gl.ARRAY_BUFFER, bufferSizes)
    gl.bufferData(gl.ARRAY_BUFFER, pointSizes, gl.STATIC_DRAW)
    gl.vertexAttribPointer(2, 1, gl.FLOAT, false, 0, 0)
    gl.enableVertexAttribArray(2)
}

/*------------ Animation support ------------*/

function doFrame() {
    if (animating) {
        updatePointCoordsForFrame();
        draw();
        requestAnimationFrame(doFrame);
    }
}

function doAnimationCheckbox() {
    let  anim = document.getElementById("animateCheckbox").checked;
    if (anim !== animating) {
        animating = anim;
        if (animating) {
            doFrame();
        }
    }
}


/*-------------------------------------------*/

/**
 * Initialize the program.  This function is called after the page has been loaded.
 */
function init() {
    try {
        canvas = document.getElementById("webglcanvas");
        let  options = {  // no need for alpha channel or depth buffer in this program
            alpha: false,
            depth: false
        };
        gl = canvas.getContext("webgl2", options);
              // (Note: this page would work with "webgl2", with no further modification.)
        if ( ! gl ) {
            throw "Browser does not support WebGL";
        }
    }
    catch (e) {
        document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not get a WebGL graphics context.</p>";
        return;
    }
    try {
        initGL();  // initialize the WebGL graphics context
    }
    catch (e) {
        document.getElementById("canvas-holder").innerHTML =
            "<p>Sorry, could not initialize the WebGL graphics context: " + e + "</p>";
        return;
    }
    document.getElementById("animateCheckbox").checked = true;
    document.getElementById("colorCheckbox").checked = true;
    document.getElementById("sizeChoice").value = "32";
    document.getElementById("animateCheckbox").onchange = doAnimationCheckbox;
    document.getElementById("colorCheckbox").onchange = function() {
        if (!animating) {
            draw();
        }
    };
    document.getElementById("sizeChoice").onchange = function() {
        if (!animating) {
            draw();
        }
    };
    doAnimationCheckbox();
}


window.onload = init;  // Arrange for init() to be called after page has loaded.

</script>
</head>
<body>

<h2>Moving Points with the WebGL POINTS primitive</h2>

<noscript><p><b>Sorry, but this page requires JavaScript.</b></p></noscript>

<p>
    <label><b><input type="checkbox" id="animateCheckbox">&nbsp;Animate</b></label>
    <label><b><input type="checkbox" id="colorCheckbox">&nbsp;Random&nbsp;Colors</b></label>
    <label><b>Point Size:</b>&nbsp;<select id="sizeChoice">
        <option value="16">Small</option>
        <option value="32">Medium</option>
        <option value="64">Large</option>
    </select></label>
</p>

<div id="canvas-holder">
<canvas id="webglcanvas" width="800" height="600"></canvas>
</div>

</body>
</html>