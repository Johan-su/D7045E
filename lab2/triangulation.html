<!DOCTYPE html>

<!--
   This page shows an animation of colored disks moving around
   in a canvas, bouncing off the edges.  The program uses WebGL.
   All of the points are drawn as single primitive of type POINTS.
   The color is an attribute in the vertex shader, allowing
   each point to be a different primitive.  The user can decide
   whether to have randomly colored points or to make all the
   points red.  The point size is a uniform variable, so all
   the points are the same size.  However, the user can select
   whether the size is large or small.
-->

<html>
<head>
<meta charset="UTF-8">
<title>Triangulation</title>
<style>
    label {
        margin-left: 30px;
    }
</style>

<script>
"use strict";



let canvas;  // The canvas where WebGL draws.
let gl;  // The WebGL graphics context.



class Vector2 {
    constructor(x, y) {
        this.x = x
        this.y = y
    }
}

function dot(v1, v2) {
    return v1.x*v2.x + v1.y*v2.y
}

function sub(v1, v2) {
    return new Vector2(v1.x - v2.x, v1.y - v2.y)
}

function add(v1, v2) {
    return new Vector2(v1.x + v2.x, v1.y + v2.y)
}

function mul(v, s) {
    return new Vector2(v.x*s, v.y*s)
}

function div(v, s) {
    return new Vector2(v.x/s, v.y/s)
}

function assert(condition) {
    if (!condition) {
        throw "Assertion failed";
    }
}

class Vector4 {
    constructor(x, y, z, w) {
        this.x = x
        this.y = y
        this.z = z
        this.w = w
    }
}


// < 0 right turn
// > 0 left turn
function orient(v1, v2, v3) {
    let v = (v3.y - v1.y)*(v2.x - v1.x) - (v3.x - v1.x)*(v2.y - v1.y);
    return -v; // -v because y coordinate is flipped in webgl
}

function rightTurn(v1, v2, v3) {
    return orient(v1, v2, v3) < 0;
}

function leftTurn(v1, v2, v3) {
    return orient(v1, v2, v3) > 0;
}

const white = new Vector4(1, 1, 1, 1);
const lightgray = new Vector4(0.1, 0.1, 0.1, 1);
const black = new Vector4(0, 0, 0, 1);
const gray = new Vector4(0.4, 0.4, 0.4, 1);
const gold = new Vector4(1, 215/255, 0, 1);
const red = new Vector4(1, 0, 0, 1);
const green = new Vector4(0, 0.5, 0, 1);
const blue = new Vector4(0, 0, 0.5, 1);
const yellow = new Vector4(1, 1, 0, 1);

// https://www.desmos.com/calculator/3r1fajunz6
function convexHull(state, start, end) {
    let upperHull = [start, start+1];

    for (let i = 2; i < end; ++i) {

        upperHull.push(i)
        
        while (upperHull.length > 2) {
            let v1 = getPos(state, upperHull[upperHull.length - 3]);
            let v2 = getPos(state, upperHull[upperHull.length - 2]);
            let v3 = getPos(state, upperHull[upperHull.length - 1]);
    
            if (rightTurn(v1, v2, v3)) {
                break;
            } else {
                upperHull.splice(upperHull.length - 2, 1)   
            }
        }
    }

    let lowerHull = [end - 1, end - 2];

    for (let i = end - 2; i-- > 0;) {

        lowerHull.push(i)

        while (lowerHull.length > 2) {
            let v1 = getPos(state, lowerHull[lowerHull.length - 3]);
            let v2 = getPos(state, lowerHull[lowerHull.length - 2]);
            let v3 = getPos(state, lowerHull[lowerHull.length - 1]);
    
            if (rightTurn(v1, v2, v3)) {
                break;
            } else {
                lowerHull.splice(lowerHull.length - 2, 1)   
            }

        }
    }

    lowerHull.splice(lowerHull.length - 1, 1)
    lowerHull.splice(0, 1)

    return [upperHull.concat(lowerHull), upperHull.length - 1];
}

function getPos(state, id) {
    return new Vector2(state.pointCoords[2*id], state.pointCoords[2*id+1])
}


class Triangle {
    constructor(pointIndices) {
        assert(pointIndices.length == 3);
        this.pointIndices = pointIndices
        this.tris = []
        this.color = null;
    }
}

class Edge {
    constructor(v1, v2, triangle) {

        if (v1.x < v2.x) {
            this.xmin = v1.x;
            this.xmax = v2.x;
        } else {
            this.xmax = v1.x;
            this.xmin = v2.x;
        }

        if (v1.y < v2.y) {
            this.ymin = v1.y;
            this.ymax = v2.y;
        } else {
            this.ymax = v1.y;
            this.ymin = v2.y;
        }

        this.triangle = triangle;
    }
}

function arraysEqual(a, b) {
    if (a === b) return true;
    if (a == null || b == null) return false;
    if (a.length !== b.length) return false;


    for (var i = 0; i < a.length; ++i) {
        if (a[i] !== b[i]) return false;
    }
    return true;
}


function update(state) {

    state.triangles = [new Triangle([0, 1, 2])];

    let [hull, upperend] = convexHull(state, 0, 3)


    for (let i = 3; i < state.pointCount; ++i) {

        // if (i == 9) break;

        let activePoint = i;



        // lower triangulation
        {
            let prevIndex = upperend;
            while (true) {
                let nextIndex = (prevIndex + 1) % hull.length;
                let prevv = getPos(state, hull[prevIndex]);
                let nextv = getPos(state, hull[nextIndex]);

                if (rightTurn(getPos(state, activePoint), prevv, nextv)) {
                    break;
                }
                state.triangles.push(new Triangle([hull[prevIndex], hull[nextIndex], activePoint]))
                prevIndex = nextIndex;
            }
        }

        // upper triangulation
        {
            let prevIndex = upperend;
            while (true) {
                let nextIndex = (prevIndex - 1 + hull.length) % hull.length;
                
                let prevv = getPos(state, hull[prevIndex]);
                let nextv = getPos(state, hull[nextIndex]);

                if (leftTurn(getPos(state, activePoint), prevv, nextv)) {
                    break;
                }
                state.triangles.push(new Triangle([hull[prevIndex], hull[nextIndex], activePoint]))
                prevIndex = nextIndex;
            }
        }

        // add activePoint to hull
        {
            // let [cheathull, cheatupperend] = convexHull(state, 0, i+1)

            hull = [...hull.slice(0, upperend+1), activePoint, ...hull.slice(upperend+1)]
            upperend += 1;

            let removedId = null;

            while (hull.length > 2) {
                let v1 = getPos(state, hull[((upperend - 2 + hull.length) % hull.length)]);
                let v2 = getPos(state, hull[((upperend - 1 + hull.length) % hull.length)]);
                let v3 = getPos(state, hull[upperend]);
        
                if (rightTurn(v1, v2, v3)) {
                    break;
                } else {
                    if (removedId == null) {
                        removedId = hull[upperend - 1];
                    }
                    hull.splice(upperend - 1, 1);
                    upperend -= 1
                }
            }

            if (removedId != null) {
                hull = [...hull.slice(0, upperend+1), removedId, ...hull.slice(upperend+1)]
            }

            while (hull.length > 2) {
                let midid = (upperend + 1) % hull.length;
                let v1 = getPos(state, hull[upperend]);
                let v2 = getPos(state, hull[midid]);
                let v3 = getPos(state, hull[(upperend + 2) % hull.length]);
        
                if (rightTurn(v1, v2, v3)) {
                    break;
                } else {
                    if (midid < upperend) {
                        upperend -= 1;
                    }
                    hull.splice(midid, 1);
                }
            }
            // assert(arraysEqual(hull, cheathull));
            // assert(upperend == cheatupperend);
        }

    }
    
    state.triangleIndicies = new Uint32Array(state.triangles.length*3);



    for (let i = 0; i < state.triangles.length; ++i) {
        let tri = state.triangles[i];
        for (let j = 0; j < tri.pointIndices.length; ++j) {
            state.triangleIndicies[3*i+j] = tri.pointIndices[j];
        }
    }


    state.edges = []
    for (let i = 0; i < state.triangles.length; ++i) {

        let v1 = getPos(state, state.triangles[i].pointIndices[0]);
        let v2 = getPos(state, state.triangles[i].pointIndices[1]);
        let v3 = getPos(state, state.triangles[i].pointIndices[2]);

        state.edges.push(new Edge(v1, v2, i))
        state.edges.push(new Edge(v2, v3, i))
        state.edges.push(new Edge(v3, v1, i))

    }

    state.edges.sort(function(a, b) {
        if (a.xmin != b.xmin) {
            return a.xmin - b.xmin;
        } else if (a.xmax != b.xmax) {
            return a.xmax - b.xmax;
        } else if (a.ymin != b.ymin) {
            return a.ymin - b.ymin;
        } else {
            return a.ymax - b.ymax;
        }
    });
    
    for (let i = 0; i < state.edges.length - 1; ++i) {
        let e1 = state.edges[i];
        let e2 = state.edges[i+1];
        
        if (e1.xmin == e2.xmin && e1.xmax == e2.xmax && e1.ymin == e2.ymin && e1.ymax == e2.ymax) {
            state.triangles[e1.triangle].tris.push(e2.triangle);
            state.triangles[e2.triangle].tris.push(e1.triangle);
        }
    }



}

let possibleColors = [red, blue, green, yellow];

function color4(state, triangleIndex) {
    let t = state.triangles[triangleIndex]; 
    if (t.color != null) {
        return;
    }

    // select non chosen color
    
    let chosenColors = [];

    for (let i = 0; i < t.tris.length; ++i) {
        let tri = state.triangles[t.tris[i]];
        if (tri.color != null) {
            chosenColors.push(tri.color);
        }
    }

    for (let i = 0; i < possibleColors.length; ++i) {
        
        if (!chosenColors.includes(possibleColors[i])) {
            t.color = possibleColors[i];
            break;
        }
    }

    // deeper
    for (let i = 0; i < t.tris.length; ++i) {
        color4(state, t.tris[i]);
    }
}


function draw(state) {

    let background_color = lightgray;

    gl.clearColor(background_color.x, background_color.y, background_color.z, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, state.glCoords);
    gl.bufferData(gl.ARRAY_BUFFER, state.pointCoords, gl.STREAM_DRAW);

        
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, state.gltriangleIndicies);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, state.triangleIndicies, gl.STREAM_DRAW)

    gl.useProgram(state.triangleShader)
    gl.uniform1f(gl.getUniformLocation(state.triangleShader, "u_height"), canvas.height);
    gl.uniform1f(gl.getUniformLocation(state.triangleShader, "u_width"), canvas.width);

    for (let i = 0; i < state.triangles.length; ++i) {
        state.triangles[i].color = null;
    }

    switch (state.triangleColorType) {
        case "monochrome": {
            for (let i = 0; i < state.triangles.length; ++i) {
                state.triangles[i].color = state.triangleColor;
            }
        } break;
        case "distance": {
            let p = new Vector2(50, 50);
            for (let i = 0; i < state.triangles.length; ++i) {

                let v1 = getPos(state, state.triangles[i].pointIndices[0]);
                let v2 = getPos(state, state.triangles[i].pointIndices[1]);
                let v3 = getPos(state, state.triangles[i].pointIndices[2]);

                let mid = new Vector2((v1.x + v2.x + v3.x) / 3, (v1.y + v2.y + v3.y) / 3);
                
                let distance = Math.hypot(p.x - mid.x, p.y - mid.y) / canvas.width;

                state.triangles[i].color = new Vector4(1-distance, 1-distance, 1-distance, 1);
            }
        } break;
        case "4color": {
            color4(state, 0);

            for (let i = 0; i < state.triangles.length; ++i) {
                assert(state.triangles[i].color != null);
            }

        } break;
    }

    for (let i = 0; i < state.triangleIndicies.length; i += 3) {
        let color = state.triangles[i/3].color;
        gl.uniform4f(gl.getUniformLocation(state.triangleShader, "u_color"), color.x, color.y, color.z, color.w);
        gl.drawElements(gl.TRIANGLES, 3, gl.UNSIGNED_INT, i*4);
    }


    gl.useProgram(state.lineShader)
    gl.uniform1f(gl.getUniformLocation(state.lineShader, "u_height"), canvas.height);
    gl.uniform1f(gl.getUniformLocation(state.lineShader, "u_width"), canvas.width);
    gl.uniform4f(gl.getUniformLocation(state.lineShader, "u_color"), state.lineColor.x, state.lineColor.y, state.lineColor.z, state.lineColor.w);

    for (let i = 0; i < state.triangleIndicies.length; i += 3) {
        gl.drawElements(gl.LINE_LOOP, 3, gl.UNSIGNED_INT, i*4);
    }

    gl.useProgram(state.pointShader)
    gl.uniform1f(gl.getUniformLocation(state.pointShader, "u_height"), canvas.height);
    gl.uniform1f(gl.getUniformLocation(state.pointShader, "u_width"), canvas.width);
    gl.uniform4f(gl.getUniformLocation(state.pointShader, "u_color"), state.pointColor.x, state.pointColor.y, state.pointColor.z, state.pointColor.w);
    gl.drawArrays(gl.POINTS, 0, state.pointCount);

}

function createShaderProgram(vertexShaderSource, fragmentShaderSource) {
   let  vsh = gl.createShader( gl.VERTEX_SHADER );
   gl.shaderSource( vsh, vertexShaderSource );
   gl.compileShader( vsh );
   if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
      throw new Error("Error in vertex shader:  " + gl.getShaderInfoLog(vsh));
   }
   let  fsh = gl.createShader( gl.FRAGMENT_SHADER );
   gl.shaderSource( fsh, fragmentShaderSource );
   gl.compileShader( fsh );
   if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
      throw new Error("Error in fragment shader:  " + gl.getShaderInfoLog(fsh));
   }
   let  prog = gl.createProgram();
   gl.attachShader( prog, vsh );
   gl.attachShader( prog, fsh );
   gl.linkProgram( prog );
   if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
      throw new Error("Link error in program:  " + gl.getProgramInfoLog(prog));
   }
   return prog;
}

let vals = [
    64.23719024658203, 544.35546875,
    108.75343322753906, 271.3231201171875,
    134.83912658691406, 342.890625,
    225.19244384765625, 130.02928161621094,
    297.04632568359375, 93.26069641113281,
    334.1434326171875, 99.70037841796875,
    408.9986877441406, 292.7887878417969,
    428.8388671875, 237.37127685546875,
    439.96392822265625, 483.65478515625,
    573.4647827148438, 334.282958984375,
]

// let vals = [
//     60.259681701660156, 519.7130126953125,
//     64.78961944580078, 163.75399780273438,
//     113.30943298339844, 315.23046875,
//     154.3426055908203, 210.44459533691406,
//     189.14710998535156, 344.9160461425781,
//     195.6725616455078, 323.6569519042969,
//     294.4981384277344, 453.55743408203125,
//     324.65576171875, 507.5606994628906,
//     379.419677734375, 317.37664794921875,
//     416.2752685546875, 531.3651123046875,
//     514.184326171875, 198.9794158935547,
//     516.9070434570312, 464.14007568359375,
//     566.7092895507812, 135.54026794433594,
//     578.7708129882812, 548.740966796875,
//     630.273193359375, 206.235595703125,
//     646.0303344726562, 356.9063720703125,
//     664.8704223632812, 248.46807861328125,
//     739.01123046875, 160.85406494140625,
// ]

let counter = 0
function getRandom(minval, maxval) {
    // return vals[counter++];
    return minval + Math.random() * (maxval - minval);
}

function getRandomInt(minval, maxval) {
    // return vals.length/2;
    return Math.round(getRandom(minval, maxval));
}


function getColorfromstr(colorstr) {
    switch (colorstr) {
        case "red": return red; break;
        case "green": return green; break;
        case "blue": return blue; break;
        case "black" : return black; break;
    }
    return white;
}

function setTriangleColoring(state, str) {
    state.triangleColorType = "monochrome";
    switch (str) {
        case "red": state.triangleColor = red; break;
        case "green": state.triangleColor = green; break;
        case "blue": state.triangleColor = blue; break;
        case "distance": {
            state.triangleColor = null;
            state.triangleColorType = "distance";
        } break;
        case "4color": {
            state.triangleColor = null;
            state.triangleColorType = "4color";
        } break;
    }
}

function resetState(state) {

    const minCount = 10;
    const maxCount = 100;

    state.pointCount = minCount;
    state.triangleColor = blue;
    state.lineColor = red;

    switch (document.getElementById("amountChoice").value) {
        case "random": state.pointCount = getRandomInt(minCount, maxCount); break;
        case "min": state.pointCount = minCount; break;
        case "max": state.pointCount = maxCount; break;
    }
    setTriangleColoring(state, document.getElementById("trianglecolorChoice").value);
    state.lineColor = getColorfromstr(document.getElementById("linecolorChoice").value);
    state.pointColor = getColorfromstr(document.getElementById("pointcolorChoice").value);

    state.pointCoords = new Float32Array(2*state.pointCount)

    const offset = 50
    let vecs = []
    for (let i = 0; i < state.pointCount; ++i) {
        vecs.push(new Vector2(getRandom(offset, canvas.width - offset), getRandom(offset, canvas.height - offset)))
    }
    vecs.sort(function(a,b) {
        return a.x - b.x;
    });

    for (let i = 0; i < vecs.length; ++i) {
        state.pointCoords[2*i] = vecs[i].x;
        state.pointCoords[2*i+1] = vecs[i].y;
    }

    gl.bindBuffer(gl.ARRAY_BUFFER, state.glCoords);
    gl.bufferData(gl.ARRAY_BUFFER, state.pointCoords, gl.STREAM_DRAW);

    update(state)
}

const pointvert =`#version 300 es
    layout(location = 0) in vec2 a_coords;

    uniform float u_width;
    uniform float u_height;
    
    void main() {
        float x = -1.0 + 2.0*(a_coords.x / u_width);
        float y = 1.0 - 2.0*(a_coords.y / u_height);
        gl_Position = vec4(x, y, 0.0, 1.0);
        gl_PointSize = 5.0;
    }`;

const pointfrag =`#version 300 es
    precision highp float;
    
    uniform vec4 u_color;
 
    out vec4 o_color;
    
    void main() {
        o_color = u_color;
    }`;

const linevert =`#version 300 es
    layout(location = 0) in vec2 a_coords;

    uniform float u_width;
    uniform float u_height;
    
    void main() {
        float x = -1.0 + 2.0*(a_coords.x / u_width);
        float y = 1.0 - 2.0*(a_coords.y / u_height);
        gl_Position = vec4(x, y, 0.0, 1.0);
    }`;

const linefrag =`#version 300 es
    precision highp float;
    
    uniform vec4 u_color;
 
    out vec4 o_color;
    
    void main() {
        o_color = u_color;
    }`;


const trianglevert =`#version 300 es
    layout(location = 0) in vec2 a_coords;

    uniform float u_width;
    uniform float u_height;
    
    void main() {
        float x = -1.0 + 2.0*(a_coords.x / u_width);
        float y = 1.0 - 2.0*(a_coords.y / u_height);
        gl_Position = vec4(x, y, 0.0, 1.0);
    }`;

const trianglefrag =`#version 300 es
    precision highp float;
    
    uniform vec4 u_color;
    out vec4 o_color;
    
    void main() {
        o_color = u_color;
    }`;

function init() {
    try {canvas = document.getElementById("webglcanvas")}
    catch (e) {
        console.log(e)
        return
    }
    gl = canvas.getContext("webgl2", {alpha: false, depth: false});
    if (!gl) {
        console.log("Browser does not support WebGL");
        return
    }
    let state = {};

    document.getElementById("amountChoice").onchange = function () {
        resetState(state)
        draw(state)
    };
    document.getElementById("trianglecolorChoice").onchange = function () {
        setTriangleColoring(state, document.getElementById("trianglecolorChoice").value)
        draw(state)
    };
    document.getElementById("linecolorChoice").onchange = function () {
        state.lineColor = getColorfromstr(document.getElementById("linecolorChoice").value)
        draw(state)
    };

    document.getElementById("pointcolorChoice").onchange = function () {
        state.pointColor = getColorfromstr(document.getElementById("pointcolorChoice").value)
        draw(state)
    };

    console.log(gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
    console.log(gl.getParameter(gl.VERSION));
    console.log(gl.getParameter(gl.RENDERER));

    state.triangleShader = createShaderProgram(trianglevert, trianglefrag);
    state.pointShader = createShaderProgram(pointvert, pointfrag);
    state.lineShader = createShaderProgram(linevert, linefrag);

    state.gltriangleIndicies = gl.createBuffer();
    state.glLineIndicies = gl.createBuffer()
    state.glCoords = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, state.glCoords);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);

    resetState(state);
    draw(state)
}


window.onload = init;  // Arrange for init() to be called after page has loaded.

</script>
</head>
<body>

<h2>Triangulation</h2>

<noscript><p><b>Sorry, but this page requires JavaScript.</b></p></noscript>

<p>
    <label>
        <b>Point Amount:</b>
        <select id="amountChoice">
            <option value="random">Random</option>
            <option value="min">Min</option>
            <option value="max">Max</option>
        </select>
    </label>
        <label>
        <b>Triangle Color:</b>
        <select id="trianglecolorChoice">
            <option value="blue">Blue</option>
            <option value="red">Red</option>
            <option value="green">Green</option>
            <option value="distance">Distance</option>
            <option value="4color">4color</option>

        </select>
    </label>
    </label>
        <label>
        <b>Edge Color:</b>
        <select id="linecolorChoice">
            <option value="red">Red</option>
            <option value="green">Green</option>
            <option value="blue">Blue</option>
            <option value="black">Black</option>
        </select>
    </label>
    </label>
        <label>
        <b>Point Color:</b>
        <select id="pointcolorChoice">
            <option value="red">Red</option>
            <option value="green">Green</option>
            <option value="blue">Blue</option>
            <option value="black">Black</option>
        </select>
    </label>
</p>


<div id="canvas-holder">
<canvas id="webglcanvas" width="800" height="600"></canvas>
</div>

</body>
</html>