<!DOCTYPE html>

<!--
   This page shows an animation of colored disks moving around
   in a canvas, bouncing off the edges.  The program uses WebGL.
   All of the points are drawn as single primitive of type POINTS.
   The color is an attribute in the vertex shader, allowing
   each point to be a different primitive.  The user can decide
   whether to have randomly colored points or to make all the
   points red.  The point size is a uniform variable, so all
   the points are the same size.  However, the user can select
   whether the size is large or small.
-->

<html>
<head>
<meta charset="UTF-8">
<title>Triangulation</title>
<style>
    label {
        margin-left: 30px;
    }
</style>

<script>
"use strict";



let canvas;  // The canvas where WebGL draws.
let gl;  // The WebGL graphics context.



class Vector2 {
    constructor(x, y) {
        this.x = x
        this.y = y
    }
}

function dot(v1, v2) {
    return v1.x*v2.x + v1.y*v2.y
}

function sub(v1, v2) {
    return new Vector2(v1.x - v2.x, v1.y - v2.y)
}

function add(v1, v2) {
    return new Vector2(v1.x + v2.x, v1.y + v2.y)
}

function mul(v, s) {
    return new Vector2(v.x*s, v.y*s)
}

function div(v, s) {
    return new Vector2(v.x/s, v.y/s)
}

function assert(condition) {
    if (!condition) {
        throw "Assertion failed";
    }
}

class Vector4 {
    constructor(x, y, z, w) {
        this.x = x
        this.y = y
        this.z = z
        this.w = w
    }
}


// > 0 right turn
// < 0 left turn
function orientation(v1, v2, v3) {
    return (v3.x - v1.x)*(v2.y - v1.y) + (v3.y - v1.y)*(v1.x - v2.x)
}

const black = new Vector4(0, 0, 0, 1)
const gray = new Vector4(0.4, 0.4, 0.4, 1)
const gold = new Vector4(1, 215/255, 0, 1)
const red = new Vector4(1, 0, 0, 1)
const green = new Vector4(0, 0.5, 0, 1)
const blue = new Vector4(0, 0, 0.5, 1)

// https://www.desmos.com/calculator/3r1fajunz6
function convexHull(state, sortedIndicies) {

    let upperHull = [sortedIndicies[0], sortedIndicies[1]];


    for (let i = 2; i < sortedIndicies.length; ++i) {

        upperHull.push(sortedIndicies[i])
             
        let v1 = getPos(state, upperHull.length - 3);
        let v2 = getPos(state, upperHull.length - 2);
        let v3 = getPos(state, upperHull.length - 1);

        
        let projectedScale = orientation(v1, v2, v3);
        if (projectedScale <= 0) {
            upperHull.splice(upperHull.length - 2, 1)   
        }
    }

    let lowerHull = [sortedIndicies[sortedIndicies.length - 1], sortedIndicies[sortedIndicies.length - 2]]

    for (let i = sortedIndicies.length - 2; i-- > 0;) {

        lowerHull.push(sortedIndicies[i])
               
        let v1 = getPos(state, lowerHull.length - 3);
        let v2 = getPos(state, lowerHull.length - 2);
        let v3 = getPos(state, lowerHull.length - 1);

        
        let projectedScale = orientation(v1, v2, v3);
        if (projectedScale > 0) {
            lowerHull.splice(lowerHull.length - 2, 1)   
        }
    }

    lowerHull.splice(lowerHull.length - 1, 1)
    lowerHull.splice(0, 1)

    return upperHull.concat(lowerHull);
}

function getPos(state, id) {
    return new Vector2(state.pointCoords[2*id], state.pointCoords[2*id+1])
}


class Triangle {
    constructor(i1, i2, i3) {
        this.i1 = i1;
        this.i2 = i2;
        this.i3 = i3;
    }
}



function visibleRangeLeft(state, hull, activePoint) {
    let av = getPos(state, activePoint);
    
    let start = 0;
    let end = hull.length;
    
    while (start < end) {
        let mid = Math.floor((start + end) / 2);
        let next = (mid + 1) % hull.length;
        let prev = (mid - 1 + hull.length) % hull.length;
        
        let midv = getPos(state, hull[mid]);

        let oprev = orientation(av, midv, getPos(state, hull[next]));
        let onext = orientation(av, midv, getPos(state, hull[prev]))  

        if (onext > 0 && oprev > 0) {
            return mid
        }

        if (onext <= 0) {
            start = mid + 1;
        } else {
            end = mid;
        }

    }

    return start  % hull.length;
}

function visibleRangeRight(state, hull, activePoint) {
    let av = getPos(state, activePoint);
    
    let start = 0;
    let end = hull.length;
    
    while (start < end) {
        let mid = Math.floor((start + end) / 2);
        let next = (mid + 1) % hull.length;
        let prev = (mid - 1 + hull.length) % hull.length;
        
        let midv = getPos(state, hull[mid]);

        let oprev = orientation(av, midv, getPos(state, hull[next]));
        let onext = orientation(av, midv, getPos(state, hull[prev]))  

        if (onext < 0 && oprev < 0) {
            return mid
        }

        if (onext >= 0) {
            start = mid + 1;
        } else {
            end = mid;
        }

    }

    return start % hull.length;
}


function TriangulateMonotone(state, triangles, visibleHull, activePoint) {


    visibleHull.push(activePoint); 

    let min = 0;
    let max = 0;

    for (let i = 0; i < visibleHull.length; ++i) {

        let v = getPos(state, visibleHull[i]);
        
        if (v.y < getPos(state, visibleHull[min]).y) min = i;
        if (v.y > getPos(state, visibleHull[max]).y) max = i;
    }

    let isLeftChain = {};
    let i = max;
    while (i != min) {
        isLeftChain[visibleHull[i]] = true;
        i = (i + 1) % visibleHull.length;
    }
    isLeftChain[visibleHull[min]] = true;

    // sort visibleHull decreasing according to y
    visibleHull.sort(function (a, b) {
        return getPos(state, b).y - getPos(state, a).y;
    });

    let stack = [visibleHull[0], visibleHull[1]]


    for (let i = 2; i < visibleHull.length; ++i) {

        let u = visibleHull[i]

        if (isLeftChain[u] == isLeftChain[stack[stack.length - 1]]) {
            let v = stack.pop()

            while (stack.length != 0) {
                triangles.push(new Triangle(prev, next, u));
            }

        } else {

            let prev = stack.pop();

            while (stack.length != 0) {
                let next = stack.pop();
                triangles.push(new Triangle(prev, next, u));
                prev = next;
            }
            stack.push(visibleHull[i - 1]);
            stack.push(u);
        }

    }

}

function update(state) {

    let indicies = new Uint32Array(state.pointCount);
    for (let i = 0; i < state.pointCount; ++i) {
        indicies[i] = i;
    }
    // sort indicies according to x
    indicies.sort(function (a, b) {
        return getPos(state, a).x - getPos(state, b).x;
    });

    let triangles = [new Triangle(indicies[0], indicies[1], indicies[2])];

    for (let i = 3; i < indicies.length; ++i) {

        let activePoint = indicies[i];

        let hull = convexHull(state, indicies.slice(0, i+1));

        let leftmost = visibleRangeLeft(state, hull, activePoint);
        let rightmost = visibleRangeRight(state, hull, activePoint);

        TriangulateMonotone(state, triangles, hull.slice(leftmost, rightmost), activePoint);
    }

    state.triangleIndicies = new Uint32Array(triangles.length*3);

    for (let i = 0; i < triangles.length; ++i) {
        state.triangleIndicies[3*i] = triangles[i].i1;
        state.triangleIndicies[3*i+1] = triangles[i].i2;
        state.triangleIndicies[3*i+2] = triangles[i].i3;
    }
}


function draw(state) {

    let background_color = gray

    gl.clearColor(background_color.x, background_color.y, background_color.z, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    
    gl.bindBuffer(gl.ARRAY_BUFFER, state.glCoords);
    gl.bufferData(gl.ARRAY_BUFFER, state.pointCoords, gl.STREAM_DRAW);


    
    gl.useProgram(state.pointShader)
    gl.uniform1f(gl.getUniformLocation(state.pointShader, "u_height"), canvas.height);
    gl.uniform1f(gl.getUniformLocation(state.pointShader, "u_width"), canvas.width);
    gl.uniform4f(gl.getUniformLocation(state.pointShader, "u_color"), red.x, red.y, red.z, red.w);
    gl.drawArrays(gl.POINTS, 0, state.pointCount);
    
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, state.gltriangleIndicies);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, state.triangleIndicies, gl.STREAM_DRAW)

    
    gl.useProgram(state.triangleShader)
    gl.uniform1f(gl.getUniformLocation(state.triangleShader, "u_height"), canvas.height);
    gl.uniform1f(gl.getUniformLocation(state.triangleShader, "u_width"), canvas.width);
    gl.uniform4f(gl.getUniformLocation(state.triangleShader, "u_color"), state.triangleColor.x, state.triangleColor.y, state.triangleColor.z, state.triangleColor.w);
    gl.drawElements(gl.TRIANGLES, state.triangleIndicies.length, gl.UNSIGNED_INT, 0);


    // gl.useProgram(state.lineShader)
    // gl.uniform1f(gl.getUniformLocation(state.lineShader, "u_height"), canvas.height);
    // gl.uniform1f(gl.getUniformLocation(state.lineShader, "u_width"), canvas.width);
    // gl.uniform4f(gl.getUniformLocation(state.lineShader, "u_color"), state.lineColor.x, state.lineColor.y, state.lineColor.z, state.lineColor.w);
    // gl.drawElements(gl.LINES, state.triangleIndicies.length / 3, gl.UNSIGNED_INT, 0);

}

function createShaderProgram(vertexShaderSource, fragmentShaderSource) {
   let  vsh = gl.createShader( gl.VERTEX_SHADER );
   gl.shaderSource( vsh, vertexShaderSource );
   gl.compileShader( vsh );
   if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
      throw new Error("Error in vertex shader:  " + gl.getShaderInfoLog(vsh));
   }
   let  fsh = gl.createShader( gl.FRAGMENT_SHADER );
   gl.shaderSource( fsh, fragmentShaderSource );
   gl.compileShader( fsh );
   if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
      throw new Error("Error in fragment shader:  " + gl.getShaderInfoLog(fsh));
   }
   let  prog = gl.createProgram();
   gl.attachShader( prog, vsh );
   gl.attachShader( prog, fsh );
   gl.linkProgram( prog );
   if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
      throw new Error("Link error in program:  " + gl.getProgramInfoLog(prog));
   }
   return prog;
}

function getRandom(minval, maxval) {
    return minval + Math.random() * (maxval - minval);
}

function getRandomInt(minval, maxval) {
    return Math.round(getRandom(minval, maxval));
}


function getColorfromstr(colorstr) {
    switch (colorstr) {
        case "red": return red; break;
        case "green": return green; break;
        case "blue": return blue; break;
    }
}

function resetState(state) {

    const minCount = 10;
    const maxCount = 100;

    state.pointCount = minCount;
    state.triangleColor = blue;
    state.lineColor = red;

    switch (document.getElementById("amountChoice").value) {
        case "random": state.pointCount = getRandomInt(minCount, maxCount); break;
        case "min": state.pointCount = minCount; break;
        case "max": state.pointCount = maxCount; break;
    }
    state.triangleColor = getColorfromstr(document.getElementById("trianglecolorChoice").value)
    state.lineColor = getColorfromstr(document.getElementById("linecolorChoice").value)

    state.pointCoords = new Float32Array(2*state.pointCount)

    const offset = 50
    for (let i = 0; i < 2*state.pointCount; ++i) {
        state.pointCoords[i] = getRandom(offset, canvas.width - offset);
        state.pointCoords[i+1] = getRandom(offset, canvas.height - offset);
    }


    gl.bindBuffer(gl.ARRAY_BUFFER, state.glCoords);
    gl.bufferData(gl.ARRAY_BUFFER, state.pointCoords, gl.STREAM_DRAW);
}

const pointvert =`#version 300 es
    layout(location = 0) in vec2 a_coords;

    uniform float u_width;
    uniform float u_height;
    
    void main() {
        float x = -1.0 + 2.0*(a_coords.x / u_width);
        float y = 1.0 - 2.0*(a_coords.y / u_height);
        gl_Position = vec4(x, y, 0.0, 1.0);
        gl_PointSize = 5.0;
    }`;

const pointfrag =`#version 300 es
    precision highp float;
    
    uniform vec4 u_color;
 
    out vec4 o_color;
    
    void main() {
        o_color = u_color;
    }`;

const trianglevert =`#version 300 es
    layout(location = 0) in vec2 a_coords;

    uniform float u_width;
    uniform float u_height;
    
    void main() {
        float x = -1.0 + 2.0*(a_coords.x / u_width);
        float y = 1.0 - 2.0*(a_coords.y / u_height);
        gl_Position = vec4(x, y, 0.0, 1.0);
    }`;

const trianglefrag =`#version 300 es
    precision highp float;
    
    uniform vec4 u_color;
 
    out vec4 o_color;
    
    void main() {
        o_color = u_color;
    }`;

function init() {
    try {canvas = document.getElementById("webglcanvas")}
    catch (e) {
        console.log(e)
        return
    }
    gl = canvas.getContext("webgl2", {alpha: false, depth: false});
    if (!gl) {
        console.log("Browser does not support WebGL");
        return
    }
    let state = {};

    document.getElementById("amountChoice").onchange = function () {
        resetState(state)
        draw(state)
    };
    document.getElementById("trianglecolorChoice").onchange = function () {
        state.triangleColor = getColorfromstr(document.getElementById("trianglecolorChoice").value)
        draw(state)
    };
    document.getElementById("linecolorChoice").onchange = function () {
        state.lineColor = getColorfromstr(document.getElementById("linecolorChoice").value)
        draw(state)
    };

    console.log(gl.getParameter(gl.SHADING_LANGUAGE_VERSION));
    console.log(gl.getParameter(gl.VERSION));
    console.log(gl.getParameter(gl.RENDERER));

    state.triangleShader = createShaderProgram(trianglevert, trianglefrag);
    state.pointShader = createShaderProgram(pointvert, pointfrag);
    state.lineShader = createShaderProgram(trianglevert, trianglefrag);

    state.gltriangleIndicies = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, state.gltriangleIndicies);


    state.glCoords = gl.createBuffer();

    gl.bindBuffer(gl.ARRAY_BUFFER, state.glCoords);
    gl.vertexAttribPointer(0, 2, gl.FLOAT, false, 0, 0);
    gl.enableVertexAttribArray(0);

    resetState(state);
    update(state)
    draw(state)
}


window.onload = init;  // Arrange for init() to be called after page has loaded.

</script>
</head>
<body>

<h2>Triangulation</h2>

<noscript><p><b>Sorry, but this page requires JavaScript.</b></p></noscript>

<p>
    <label>
        <b>Point Amount:</b>
        <select id="amountChoice">
            <option value="random">Random</option>
            <option value="min">Min</option>
            <option value="max">Max</option>
        </select>
    </label>
        <label>
        <b>Triangle Color:</b>
        <select id="trianglecolorChoice">
            <option value="blue">Blue</option>
            <option value="red">Red</option>
            <option value="green">Green</option>
        </select>
    </label>
    </label>
        <label>
        <b>Edge Color:</b>
        <select id="linecolorChoice">
            <option value="red">Red</option>
            <option value="green">Green</option>
            <option value="blue">Blue</option>
        </select>
    </label>
</p>


<div id="canvas-holder">
<canvas id="webglcanvas" width="800" height="600"></canvas>
</div>

</body>
</html>